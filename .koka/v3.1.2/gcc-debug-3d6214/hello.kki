module interface hello
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/exn = std/core/exn pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/string = std/core/string pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/either = std/core/either pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/core = std/core = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 

// Operations:
// ```koka
// ctl get
// ```
pub recursive effect type get[27,1,27,16] <a,(e :: E),b> :: (V, E, V) -> V {
  pub con @Hnd-get[27,1,27,16](@cfc: std/core/types/int, @ctl-get: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(get :: (V, E, V) -> V)<a>,(e :: E),b>){0,2,8} : forall<a,(e :: E),b> (std/core/types/int, (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(get :: (V, E, V) -> V)<a>,(e :: E),b>) -> (get :: (V, E, V) -> V)<a,(e :: E),b>;
};
// An effect providing a val `is-verbose : bool`

// Operations:
// ```koka
// val is-verbose
// ```
pub recursive effect type is-verbose[8,1,8,17] <(e :: E),a> :: (E, V) -> V {
  pub con @Hnd-is-verbose[8,1,8,17](@cfc: std/core/types/int, @val-is-verbose: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(is-verbose :: (E, V) -> V),(e :: E),a>){0,2,8} : forall<(e :: E),a> (std/core/types/int, (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(is-verbose :: (E, V) -> V),(e :: E),a>) -> (is-verbose :: (E, V) -> V)<(e :: E),a>;
};

// Operations:
// ```koka
// fun log-debug
// fun log-info
// ```
pub recursive effect type log[11,1,11,10] <(e :: E),a> :: (E, V) -> V {
  pub con @Hnd-log[11,1,11,10](@cfc: std/core/types/int, @fun-log-debug: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>, @fun-log-info: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>){0,3,8} : forall<(e :: E),a> (std/core/types/int, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) -> (log :: (E, V) -> V)<(e :: E),a>;
};

// Operations:
// ```koka
// ctl throw-string
// ```
pub recursive effect type throw-string[25,1,25,22] <(e :: E),a> :: (E, V) -> V {
  pub con @Hnd-throw-string[25,1,25,22](@cfc: std/core/types/int, @ctl-throw-string: forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(throw-string :: (E, V) -> V),(e :: E),a>){0,2,8} : forall<(e :: E),a> (std/core/types/int, forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(throw-string :: (E, V) -> V),(e :: E),a>) -> (throw-string :: (E, V) -> V)<(e :: E),a>;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `@cfc` constructor field of the `:get` type.
 fun get/@cfc[27,1,27,16] : forall<a,(e :: E),b> (^ get : (get :: (V, E, V) -> V)<a,(e :: E),b>) -> std/core/types/int;
// Automatically generated. Retrieves the `@ctl-get` constructor field of the `:get` type.
 fun get/@ctl-get[27,15,27,23] : forall<a,(e :: E),b> (^ get : (get :: (V, E, V) -> V)<a,(e :: E),b>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(get :: (V, E, V) -> V)<a>,(e :: E),b>;
// Automatically generated. Retrieves the `@cfc` constructor field of the `:is-verbose` type.
 fun is-verbose/@cfc[8,1,8,17] : forall<(e :: E),a> (^ @this : (is-verbose :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@val-is-verbose` constructor field of the `:is-verbose` type.
 fun is-verbose/@val-is-verbose[9,7,9,23] : forall<(e :: E),a> (^ @this : (is-verbose :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(is-verbose :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@cfc` constructor field of the `:log` type.
 fun log/@cfc[11,1,11,10] : forall<(e :: E),a> (^ log : (log :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@fun-log-debug` constructor field of the `:log` type.
 fun log/@fun-log-debug[12,7,12,34] : forall<(e :: E),a> (^ log : (log :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-log-info` constructor field of the `:log` type.
 fun log/@fun-log-info[13,7,13,33] : forall<(e :: E),a> (^ log : (log :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@cfc` constructor field of the `:throw-string` type.
 fun throw-string/@cfc[25,1,25,22] : forall<(e :: E),a> (^ @this : (throw-string :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@ctl-throw-string` constructor field of the `:throw-string` type.
 fun throw-string/@ctl-throw-string[25,12,25,44] : forall<(e :: E),a,b> (^ @this : (throw-string :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(throw-string :: (E, V) -> V),(e :: E),a>;
pub  fun hello-ten[1,5,1,13] : () -> <(std/core/console/console :: X),(std/core/types/div :: X)> ();
// runtime tag for the effect `:is-verbose`
pub val @tag-is-verbose[8,1,8,17] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(is-verbose :: (E, V) -> V)>;
// handler for the effect `:is-verbose`
pub  fun @handle-is-verbose[8,8,8,17] : forall<a,(e :: E),b> (hnd : (is-verbose :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(is-verbose :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// select `@val-is-verbose` operation out of effect `:is-verbose`
pub  fun @select-val-is-verbose[9,7,9,23] : forall<(e :: E),a> (^ hnd : (is-verbose :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(is-verbose :: (E, V) -> V),(e :: E),a>;
// Call the `val is-verbose` operation of the effect `:is-verbose`
pub  fun @val-is-verbose[9,7,9,16] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(is-verbose :: (E, V) -> V)>> std/core/types/bool;
// Call the `val is-verbose` operation of the effect `:is-verbose`
pub val is-verbose[9,7,9,16] : (std/core/types/@valueop :: (E, V) -> V)<<(std/core/types/handled :: ((E, V) -> V) -> X)<(is-verbose :: (E, V) -> V)>>,std/core/types/bool>;
// runtime tag for the effect `:log`
pub val @tag-log[11,1,11,10] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(log :: (E, V) -> V)>;
// handler for the effect `:log`
pub  fun @handle-log[11,8,11,10] : forall<a,(e :: E),b> (hnd : (log :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// select `log-debug` operation out of effect `:log`
pub  fun @select-log-debug[12,7,12,34] : forall<(e :: E),a> (^ hnd : (log :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>;
// Call the `fun log-debug` operation of the effect `:log`
pub  fun log-debug[12,7,12,15] : (msg : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>> ();
// select `log-info` operation out of effect `:log`
pub  fun @select-log-info[13,7,13,33] : forall<(e :: E),a> (^ hnd : (log :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>;
// Call the `fun log-info` operation of the effect `:log`
pub  fun log-info[13,7,13,14] : (msg : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-log@10039[1,0,1,0] : (msg : std/core/types/string, @y-x10018 : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(is-verbose :: (E, V) -> V)>> ();
pub  fun log[15,5,15,7] : (msg : std/core/types/string) -> <(std/core/console/console :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(is-verbose :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-serve@10040[1,0,1,0] : (wild_ : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>> ();
pub  fun serve[20,5,20,9] : (port : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>> ();
// runtime tag for the effect `:throw-string`
pub val @tag-throw-string[25,1,25,22] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(throw-string :: (E, V) -> V)>;
// handler for the effect `:throw-string`
pub  fun @handle-throw-string[25,12,25,22] : forall<a,(e :: E),b> (hnd : (throw-string :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(throw-string :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// select `throw-string` operation out of effect `:throw-string`
pub  fun @select-throw-string[25,12,25,44] : forall<a,(e :: E),b> (^ hnd : (throw-string :: (E, V) -> V)<(e :: E),b>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,a,(throw-string :: (E, V) -> V),(e :: E),b>;
// Call the `ctl throw-string` operation of the effect `:throw-string`
pub  fun throw-string[25,12,25,23] : forall<a> (msg : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(throw-string :: (E, V) -> V)>> a;
// runtime tag for the effect `:get`
pub val @tag-get[27,1,27,16] : forall<a> (std/core/hnd/htag :: ((E, V) -> V) -> V)<(get :: (V, E, V) -> V)<a>>;
// handler for the effect `:get`
pub  fun @handle-get[27,15,27,16] : forall<a,b,(e :: E),c> (hnd : (get :: (V, E, V) -> V)<a,(e :: E),c>, ret : (res : b) -> (e :: E) c, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(get :: (V, E, V) -> V)<a>>|(e :: E)> b) -> (e :: E) c;
// select `get` operation out of effect `:get`
pub  fun @select-get[27,15,27,23] : forall<a,(e :: E),b> (^ hnd : (get :: (V, E, V) -> V)<a,(e :: E),b>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(get :: (V, E, V) -> V)<a>,(e :: E),b>;
// Call the `ctl get` operation of the effect `:get`
pub  fun get[27,15,27,17] : forall<a> () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(get :: (V, E, V) -> V)<a>>> a;
pub  fun safe-div[29,5,29,12] : (m : std/core/types/int, n : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(throw-string :: (E, V) -> V)>> std/core/types/int;
// monadic lift
 fun @mlift-report-get-mn-and-div@10041[1,0,1,0] : (m : std/core/types/int, n : std/core/types/int, result : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(throw-string :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(get :: (V, E, V) -> V)<std/core/types/int>>> ();
// monadic lift
 fun @mlift-report-get-mn-and-div@10042[1,0,1,0] : (m : std/core/types/int, n : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(get :: (V, E, V) -> V)<std/core/types/int>>,(std/core/console/console :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(throw-string :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-report-get-mn-and-div@10043[1,0,1,0] : (m : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(get :: (V, E, V) -> V)<std/core/types/int>>,(std/core/console/console :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(throw-string :: (E, V) -> V)>> ();
pub  fun report-get-mn-and-div[35,5,35,25] : () -> <(std/core/console/console :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(get :: (V, E, V) -> V)<std/core/types/int>>,(std/core/types/handled :: ((E, V) -> V) -> X)<(throw-string :: (E, V) -> V)>> ();
pub  fun to-maybe[43,5,43,12] : forall<a> (action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(throw-string :: (E, V) -> V)>,(std/core/console/console :: X)> a) -> <(std/core/console/console :: X)> (std/core/types/maybe :: V -> V)<a>;
pub  fun use-get-and-div[52,5,52,19] : () -> <(std/core/console/console :: X)> (std/core/types/list :: V -> V)<()>;
pub  fun main[63,5,63,8] : () -> <(std/core/console/console :: X)> ();
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline borrow "^"  fun get/@cfc // inline size: 0
  = forall<a,(e :: E),b> fn(get@0: (get :: (V, E, V) -> V)<a,(e :: E),b>){
    (match (get@0) {
      ((@skip hello/@Hnd-get((@x: std/core/types/int) : std/core/types/int, (@pat@0: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(get :: (V, E, V) -> V)<a>,(e :: E),b>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(get :: (V, E, V) -> V)<a>,(e :: E),b>) : (get :: (V, E, V) -> V)<a,(e :: E),b> ) as @pat: ((get :: (V, E, V) -> V)<a,(e :: E),b>))
         -> @x;
    });
  };
inline borrow "^"  fun get/@ctl-get // inline size: 0
  = forall<a,(e :: E),b> fn(get@0: (get :: (V, E, V) -> V)<a,(e :: E),b>){
    (match (get@0) {
      ((@skip hello/@Hnd-get((@pat@0: std/core/types/int) : std/core/types/int, (@x: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(get :: (V, E, V) -> V)<a>,(e :: E),b>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(get :: (V, E, V) -> V)<a>,(e :: E),b>) : (get :: (V, E, V) -> V)<a,(e :: E),b> ) as @pat: ((get :: (V, E, V) -> V)<a,(e :: E),b>))
         -> @x;
    });
  };
inline borrow "^"  fun is-verbose/@cfc // inline size: 0
  = forall<(e :: E),a> fn(@this: (is-verbose :: (E, V) -> V)<(e :: E),a>){
    (match (@this) {
      ((@skip hello/@Hnd-is-verbose((@x: std/core/types/int) : std/core/types/int, (@pat@0: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(is-verbose :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(is-verbose :: (E, V) -> V),(e :: E),a>) : (is-verbose :: (E, V) -> V)<(e :: E),a> ) as @pat: ((is-verbose :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun is-verbose/@val-is-verbose // inline size: 0
  = forall<(e :: E),a> fn(@this: (is-verbose :: (E, V) -> V)<(e :: E),a>){
    (match (@this) {
      ((@skip hello/@Hnd-is-verbose((@pat@0: std/core/types/int) : std/core/types/int, (@x: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(is-verbose :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(is-verbose :: (E, V) -> V),(e :: E),a>) : (is-verbose :: (E, V) -> V)<(e :: E),a> ) as @pat: ((is-verbose :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun log/@cfc // inline size: 0
  = forall<(e :: E),a> fn(log@0: (log :: (E, V) -> V)<(e :: E),a>){
    (match (log@0) {
      ((@skip hello/@Hnd-log((@x: std/core/types/int) : std/core/types/int, (@pat@0: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (log :: (E, V) -> V)<(e :: E),a> ) as @pat: ((log :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun log/@fun-log-debug // inline size: 0
  = forall<(e :: E),a> fn(log@0: (log :: (E, V) -> V)<(e :: E),a>){
    (match (log@0) {
      ((@skip hello/@Hnd-log((@pat@0: std/core/types/int) : std/core/types/int, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (log :: (E, V) -> V)<(e :: E),a> ) as @pat: ((log :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun log/@fun-log-info // inline size: 0
  = forall<(e :: E),a> fn(log@0: (log :: (E, V) -> V)<(e :: E),a>){
    (match (log@0) {
      ((@skip hello/@Hnd-log((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (log :: (E, V) -> V)<(e :: E),a> ) as @pat: ((log :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun throw-string/@cfc // inline size: 0
  = forall<(e :: E),a> fn(@this: (throw-string :: (E, V) -> V)<(e :: E),a>){
    (match (@this) {
      ((@skip hello/@Hnd-throw-string((@x: std/core/types/int) : std/core/types/int, (@pat@0: (forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(throw-string :: (E, V) -> V),(e :: E),a>)) : (forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(throw-string :: (E, V) -> V),(e :: E),a>)) : (throw-string :: (E, V) -> V)<(e :: E),a> ) as @pat: ((throw-string :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun throw-string/@ctl-throw-string // inline size: 0
  = forall<(e :: E),a,b> fn(@this: (throw-string :: (E, V) -> V)<(e :: E),a>){
    (match (@this) {
      ((@skip hello/@Hnd-throw-string((@pat@0: std/core/types/int) : std/core/types/int, (@x: (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,c,(throw-string :: (E, V) -> V),(e :: E),a>)) : (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,c,(throw-string :: (E, V) -> V),(e :: E),a>)) : (throw-string :: (E, V) -> V)<(e :: E),a> ) as @pat: ((throw-string :: (E, V) -> V)<(e :: E),a>))
         -> @x<b>;
    });
  };
inline borrow "^"  fun @select-val-is-verbose // inline size: 0
  = forall<(e :: E),a> fn(hnd: (is-verbose :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip hello/@Hnd-is-verbose((@pat@0: std/core/types/int) : std/core/types/int, (@val-is-verbose@0: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(is-verbose :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(is-verbose :: (E, V) -> V),(e :: E),a>) : (is-verbose :: (E, V) -> V)<(e :: E),a> ) as @pat: ((is-verbose :: (E, V) -> V)<(e :: E),a>))
         -> @val-is-verbose@0;
    });
  };
inline  fun @val-is-verbose // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(is-verbose :: (E, V) -> V)>>>(){
    std/core/hnd/@perform0<std/core/types/bool,<(std/core/types/handled :: ((E, V) -> V) -> X)<(is-verbose :: (E, V) -> V)>>,(is-verbose :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(is-verbose :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(is-verbose :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(is-verbose :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(is-verbose :: (E, V) -> V)>>((std/core/hnd/@evv-at<(is-verbose :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(is-verbose :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(is-verbose :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), hello/@select-val-is-verbose);
  };
inline borrow "^"  fun @select-log-debug // inline size: 0
  = forall<(e :: E),a> fn(hnd: (log :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip hello/@Hnd-log((@pat@0: std/core/types/int) : std/core/types/int, (@fun-log-debug: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (log :: (E, V) -> V)<(e :: E),a> ) as @pat: ((log :: (E, V) -> V)<(e :: E),a>))
         -> @fun-log-debug;
    });
  };
inline  fun log-debug // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>>>(msg: std/core/types/string){
    std/core/hnd/@perform1<std/core/types/string,(),(log :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(log :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(log :: (E, V) -> V)>>((std/core/hnd/@evv-at<(log :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), hello/@select-log-debug, msg);
  };
inline borrow "^"  fun @select-log-info // inline size: 0
  = forall<(e :: E),a> fn(hnd: (log :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip hello/@Hnd-log((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>, (@fun-log-info: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(),(log :: (E, V) -> V),(e :: E),a>) : (log :: (E, V) -> V)<(e :: E),a> ) as @pat: ((log :: (E, V) -> V)<(e :: E),a>))
         -> @fun-log-info;
    });
  };
inline  fun log-info // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>>>(msg: std/core/types/string){
    std/core/hnd/@perform1<std/core/types/string,(),(log :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(log :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(log :: (E, V) -> V)>>((std/core/hnd/@evv-at<(log :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(log :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), hello/@select-log-info, msg);
  };
inline borrow "^"  fun @select-throw-string // inline size: 0
  = forall<a,(e :: E),b> fn(hnd: (throw-string :: (E, V) -> V)<(e :: E),b>){
    (match (hnd) {
      ((@skip hello/@Hnd-throw-string((@pat@0: std/core/types/int) : std/core/types/int, (@ctl-throw-string: (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,c,(throw-string :: (E, V) -> V),(e :: E),b>)) : (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,c,(throw-string :: (E, V) -> V),(e :: E),b>)) : (throw-string :: (E, V) -> V)<(e :: E),b> ) as @pat: ((throw-string :: (E, V) -> V)<(e :: E),b>))
         -> @ctl-throw-string<a>;
    });
  };
inline  fun throw-string // inline size: 5
  = forall<a> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(throw-string :: (E, V) -> V)>>>(msg: std/core/types/string){
    std/core/hnd/@perform1<std/core/types/string,a,(throw-string :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(throw-string :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(throw-string :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(throw-string :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(throw-string :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(throw-string :: (E, V) -> V)>>((std/core/hnd/@evv-at<(throw-string :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(throw-string :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(throw-string :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),b> hello/@select-throw-string<a,(e :: E),b>), msg);
  };
inline borrow "^"  fun @select-get // inline size: 0
  = forall<a,(e :: E),b> fn(hnd: (get :: (V, E, V) -> V)<a,(e :: E),b>){
    (match (hnd) {
      ((@skip hello/@Hnd-get((@pat@0: std/core/types/int) : std/core/types/int, (@ctl-get: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(get :: (V, E, V) -> V)<a>,(e :: E),b>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(get :: (V, E, V) -> V)<a>,(e :: E),b>) : (get :: (V, E, V) -> V)<a,(e :: E),b> ) as @pat: ((get :: (V, E, V) -> V)<a,(e :: E),b>))
         -> @ctl-get;
    });
  };
inline  fun get // inline size: 5
  = forall<a> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(get :: (V, E, V) -> V)<a>>>>(){
    std/core/hnd/@perform0<a,<(std/core/types/handled :: ((E, V) -> V) -> X)<(get :: (V, E, V) -> V)<a>>>,(get :: (V, E, V) -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(get :: (V, E, V) -> V)<a>>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(get :: (V, E, V) -> V)<a>>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(get :: (V, E, V) -> V)<a>>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(get :: (V, E, V) -> V)<a>>>((std/core/hnd/@evv-at<(get :: (V, E, V) -> V)<a>>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(get :: (V, E, V) -> V)<a>>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(get :: (V, E, V) -> V)<a>>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),b> hello/@select-get<a,(e :: E),b>));
  };
 fun main // inline size: 3
  = fn<<(std/core/console/console :: X)>>(){
    val x@10010[1,0,1,0] : (std/core/types/list :: V -> V)<()>
          = hello/use-get-and-div();
    std/core/console/printsln((std/core/list/show<(),(std/core/types/total :: E)>(x@10010, std/core/tuple/#unit/show)));
  };